<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Precipitazioni annuali Zagarolo</title>
  <!-- ECharts v5 CDN with fallback -->
  <script>
    // Check if ECharts loaded, otherwise create a fallback
    function loadECharts() {
      if (typeof echarts !== 'undefined') {
        return Promise.resolve();
      }
      
      // Fallback: Try to load from alternative CDN
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/echarts@5/dist/echarts.min.js';
        script.onload = resolve;
        script.onerror = () => {
          // If all CDNs fail, create a simple visualization fallback
          window.echarts = createSimpleChartFallback();
          resolve();
        };
        document.head.appendChild(script);
      });
    }
    
    // Simple chart fallback that creates a basic chart
    function createSimpleChartFallback() {
      return {
        graphic: {
          LinearGradient: function(x1, y1, x2, y2, colorStops) {
            return `linear-gradient(to bottom, ${colorStops[0].color}, ${colorStops[1].color})`;
          }
        },
        init: (container) => ({
          setOption: (option) => {
            // Create a simple fallback visualization showing recent years only
            const allData = option.series ? option.series[0].data : [800, 950, 700, 1100, 900, 850];
            const allYears = option.xAxis && option.xAxis[0] ? option.xAxis[0].data : ['2019','2020','2021','2022','2023','2024'];
            
            // Show only last 10 years to prevent overcrowding
            const recentCount = Math.min(10, allData.length);
            const data = allData.slice(-recentCount);
            const years = allYears.slice(-recentCount);
            
            const maxVal = Math.max(...data);
            const minVal = Math.min(...data);
            const maxIdx = data.indexOf(maxVal);
            const minIdx = data.indexOf(minVal);
            
            let html = `
              <div style="padding: 10px; height: 100%; display: flex; flex-direction: column; overflow: hidden;">
                <div style="text-align: center; margin-bottom: 6px; flex-shrink: 0;">
                  <h3 style="margin: 0; font-size: 13px; color: #1a202c; font-weight: 600;">Precipitazioni annuali (ultimi ${recentCount} anni)</h3>
                  <p style="margin: 2px 0 0 0; font-size: 10px; color: #666;">📊 Versione semplificata - Totale anni disponibili: ${allData.length}</p>
                </div>
                <div style="flex: 1; display: flex; align-items: end; justify-content: space-around; border-bottom: 2px solid #e5e7eb; min-height: 0; padding: 0 4px;">
            `;
            
            data.forEach((value, index) => {
              const height = Math.max((value / maxVal) * 85, 8); // Min 8% height
              const isMax = index === maxIdx;
              const isMin = index === minIdx;
              const color = isMax ? '#22c55e' : isMin ? '#ef4444' : '#2563eb';
              
              html += `
                <div style="display: flex; flex-direction: column; align-items: center; margin: 0 1px; flex: 1; max-width: 40px;">
                  <div style="background: ${color}; width: 100%; height: ${height}%; min-height: 8px; border-radius: 2px 2px 0 0; opacity: 0.85; position: relative;">
                    ${isMax || isMin ? `<div style="position: absolute; top: -16px; left: 50%; transform: translateX(-50%); font-size: 8px; color: ${color}; font-weight: bold;">${isMax ? 'MAX' : 'MIN'}</div>` : ''}
                  </div>
                  <div style="font-size: 9px; margin-top: 2px; color: #555; font-weight: 500; text-align: center;">${years[index]}</div>
                  <div style="font-size: 8px; color: #777; text-align: center;">${value}mm</div>
                </div>
              `;
            });
            
            html += `
                </div>
                <div style="text-align: center; margin-top: 4px; font-size: 9px; color: #888; flex-shrink: 0;">
                  Max: ${maxVal}mm (${years[maxIdx]}) • Min: ${minVal}mm (${years[minIdx]})
                </div>
              </div>
            `;
            
            container.innerHTML = html;
          },
          resize: () => {}
        })
      };
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root {
      --bg: #f6f8fa;
      --fg: #1a202c;
      --muted: #6b7280;
      --primary: #2563eb;
      --accent: #0ea5e9;
      --border: #e5e7eb;
      --header-bg: #fff;
      --card-bg: #fff;
    }
    html, body {
      height: 100vh;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      font-size: 14px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 12px 24px 6px 24px;
      border-bottom: 1px solid var(--border);
      background: var(--header-bg);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 3px;
      box-shadow: 0 2px 8px 0 rgba(0,0,0,0.03);
      flex-shrink: 0;
    }
    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
      color: var(--primary);
      letter-spacing: -0.5px;
      line-height: 1.2;
    }
    .hint {
      color: var(--muted);
      font-size: 0.85rem;
      margin: 0;
      line-height: 1.3;
    }
    #app {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      background: var(--bg);
      overflow: hidden;
    }
    #controls {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 24px;
      border-bottom: 1px solid var(--border);
      background: var(--card-bg);
      min-height: 32px;
      flex-shrink: 0;
    }
    #status {
      font-size: 0.85rem;
      color: var(--muted);
      margin-left: 6px;
    }
    #chart {
      flex: 1;
      width: 100%;
      min-height: 0;
      background: var(--card-bg);
      border-radius: 0 0 8px 8px;
      box-shadow: 0 2px 12px 0 rgba(0,0,0,0.04);
      overflow: hidden;
    }
    button {
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 6px 14px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.15s;
      box-shadow: 0 1px 2px 0 rgba(0,0,0,0.03);
    }
    button:hover {
      background: var(--accent);
    }
    code {
      background: #e0e7ef;
      color: var(--primary);
      padding: 2px 8px;
      border-radius: 6px;
      font-size: 0.95em;
    }
    @media (max-width: 600px) {
      header, #controls { 
        padding-left: 12px; 
        padding-right: 12px; 
      }
      h1 { 
        font-size: 1.25rem; 
      }
      .hint {
        font-size: 0.8rem;
      }
      #app { 
        height: calc(100vh - 60px); 
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Precipitazioni annuali — Zagarolo</h1>
    <span class="hint">Analisi storica delle precipitazioni e nevicate.<br>Fonte dati: <code>precipitations_per_year.json</code></span>
  </header>

  <div id="app">
    <div id="controls">
      <button id="reload" title="Ricarica i dati dal file JSON">🔄 Ricarica dati</button>
      <span id="status">Pronto.</span>
    </div>
    <div id="chart" role="img" aria-label="Grafico precipitazioni e neve annuali"></div>
  </div>

  <script>
    // ⬇️ Struttura attesa di precipitations_per_year.json:
    // [
    //   { "anno": "2019", "totale_precipitazioni": 800.5, "totale_neve": 13 },
    //   ...
    // ]

    const chartEl = document.getElementById('chart');
    const statusEl = document.getElementById('status');
    const reloadBtn = document.getElementById('reload');
    
    // Initialize chart after ECharts loads
    loadECharts().then(() => {
      window.chart = echarts.init(chartEl, null, { renderer: 'canvas' });
      // Start the application
      loadData();
    });

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    function baseOption() {
      return {
        backgroundColor: 'transparent',
        tooltip: {
          trigger: 'axis',
          backgroundColor: '#fff',
          borderColor: '#dbeafe',
          borderWidth: 1,
          textStyle: { color: '#222', fontSize: 14 }
        },
        legend: { show: false },
        grid: { left: 48, right: 28, top: 40, bottom: 32 },
        xAxis: { type: 'category', boundaryGap: true, axisTick: { show: false } },
        yAxis: { type: 'value', name: 'mm', splitLine: { show: true } },
        series: []
      };
    }

    async function loadData(url = 'precipitations_per_year.json') {
      setStatus('Caricamento dati…');
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const payload = await res.json();

        // Estraggo anni e valori
        const years = payload.map(row => row.anno ?? row.year);
        const valuesPrecip = payload.map(row => row.totale_precipitazioni ?? row.total_precipitation);
        const valuesNeve = payload.map(row => row.totale_neve ?? row.total_snow);

        // Trova indice max e min per precipitazioni
        const maxIdx = valuesPrecip.indexOf(Math.max(...valuesPrecip));
        const minIdx = valuesPrecip.indexOf(Math.min(...valuesPrecip));

        // Calcola il massimo della neve e della pioggia
        const maxNeve = Math.max(...valuesNeve);
        const maxPrecip = Math.max(...valuesPrecip);

        // Imposta il massimo della yAxis di destra (neve) in modo che il valore massimo della neve
        // sia circa 1/3 dell'altezza del grafico (cioè 1/3 del massimo della yAxis di sinistra)
        const maxYNeve = maxNeve > 0 ? maxNeve * 3 : 10;

        const option = baseOption();
  // Nessun titolo nel grafico
        option.xAxis = [
          {
            type: 'category',
            boundaryGap: true,
            axisTick: { show: false },
            data: years,
            axisLabel: { color: '#1a202c', fontWeight: 500, fontSize: 11 }
          }
        ];
        option.yAxis = [
          {
            type: 'value',
            name: 'mm pioggia',
            splitLine: { show: true, lineStyle: { color: '#e5e7eb' } },
            axisLabel: { color: '#1a202c', fontWeight: 500, fontSize: 11 },
            nameTextStyle: { color: '#1a202c', fontWeight: 600, fontSize: 12 }
          },
          {
            type: 'value',
            name: 'cm neve',
            splitLine: { show: false },
            position: 'right',
            axisLabel: { color: '#2563eb', fontWeight: 500, fontSize: 11 },
            nameTextStyle: { color: '#2563eb', fontWeight: 600, fontSize: 12 },
            max: maxYNeve
          }
        ];
        option.legend = { data: ['Precipitazioni', 'Neve'], top: 8, textStyle: { color: '#1a202c', fontWeight: 500, fontSize: 12 } };
        option.series = [
          {
            name: 'Precipitazioni',
            type: 'line',
            yAxisIndex: 0,
            data: valuesPrecip,
            itemStyle: { color: '#2563eb' },
            lineStyle: { width: 3, color: '#2563eb' },
            symbol: 'circle',
            symbolSize: 10,
            smooth: 0.7,
            areaStyle: {
              color: (typeof echarts !== 'undefined' && echarts.graphic) ? 
                new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                  { offset: 0, color: 'rgba(37,99,235,0.18)' },
                  { offset: 1, color: 'rgba(37,99,235,0.01)' }
                ]) : 'rgba(37,99,235,0.1)'
            },
            markPoint: {
              symbolSize: 48,
              label: { fontSize: 10 }, // Imposta la dimensione del font per tutte le etichette
              data: [
                {
                  name: 'Massimo',
                  value: valuesPrecip[maxIdx],
                  xAxis: maxIdx,
                  yAxis: valuesPrecip[maxIdx],
                  symbol: 'pin',
                  itemStyle: { color: '#22c55e' },
                  // Mostra l'anno come etichetta
                  label: { formatter: years[maxIdx], color: '#fff', fontWeight: 'bold', fontSize: 10 }
                },
                {
                  name: 'Minimo',
                  value: valuesPrecip[minIdx],
                  xAxis: minIdx,
                  yAxis: valuesPrecip[minIdx],
                  symbol: 'pin',
                  itemStyle: { color: '#ef4444' },
                  // Mostra l'anno come etichetta
                  label: { formatter: years[minIdx], color: '#fff', fontWeight: 'bold', fontSize: 10 }
                }
              ]
            }
          },
          {
            name: 'Neve',
            type: 'bar',
            yAxisIndex: 1,
            data: valuesNeve,
            itemStyle: {
              color: '#0ea5e9',
              opacity: 0.18,
              borderColor: '#2563eb',
              borderWidth: 2
            },
            barWidth: '60%',
            emphasis: { focus: 'series' },
            markPoint: {
              symbolSize: 48,
              data: [
                {
                  name: 'Massimo Neve',
                  value: maxNeve,
                  xAxis: valuesNeve.indexOf(maxNeve),
                  yAxis: maxNeve,
                  symbol: 'pin',
                  itemStyle: {
                    color: '#fff', // Pin bianco
                    borderColor: '#2563eb',
                    borderWidth: 1.5
                  },
                  label: { formatter: years[valuesNeve.indexOf(maxNeve)], color: '#2563eb', fontWeight: 'bold', fontSize: 10 }
                }
              ]
            }
          }
        ];

        chart.setOption(option, true);
        setStatus('Dati caricati.');
      } catch (err) {
        console.error(err);
        setStatus(`Errore nel caricamento: ${err.message}. Uso dati di fallback.`);
        // Fallback: dati statici
        const fallbackMaxNeve = 13;
        const fallbackMaxYNeve = fallbackMaxNeve * 3;
        chart.setOption({
          ...baseOption(),
          // Nessun titolo nel fallback
          xAxis: [
            {
              type: 'category',
              boundaryGap: true,
              data: ['2019','2020','2021','2022','2023','2024'],
              axisLabel: { color: '#1a202c', fontWeight: 500, fontSize: 11 }
            }
          ],
          yAxis: [
            {
              type: 'value',
              name: 'mm pioggia',
              splitLine: { show: true, lineStyle: { color: '#e5e7eb' } },
              axisLabel: { color: '#1a202c', fontWeight: 500, fontSize: 11 },
              nameTextStyle: { color: '#1a202c', fontWeight: 600, fontSize: 12 }
            },
            {
              type: 'value',
              name: 'cm neve',
              splitLine: { show: false },
              position: 'right',
              axisLabel: { color: '#2563eb', fontWeight: 500, fontSize: 11 },
              nameTextStyle: { color: '#2563eb', fontWeight: 600, fontSize: 12 },
              max: fallbackMaxYNeve
            }
          ],
          legend: { data: ['Precipitazioni', 'Neve'], top: 8, textStyle: { color: '#1a202c', fontWeight: 500, fontSize: 12 } },
          series: [
            {
              name: 'Precipitazioni',
              type: 'line',
              yAxisIndex: 0,
              data: [800, 950, 700, 1100, 900, 850],
              itemStyle: { color: '#2563eb' },
              lineStyle: { width: 3, color: '#2563eb' },
              symbol: 'circle',
              symbolSize: 10,
              smooth: 0.7,
              areaStyle: {
                color: (typeof echarts !== 'undefined' && echarts.graphic) ? 
                  new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                    { offset: 0, color: 'rgba(37,99,235,0.18)' },
                    { offset: 1, color: 'rgba(37,99,235,0.01)' }
                  ]) : 'rgba(37,99,235,0.1)'
              },
              markPoint: {
                symbolSize: 48,
                data: [
                  {
                    name: 'Massimo',
                    value: 1100,
                    xAxis: 3,
                    yAxis: 1100,
                    symbol: 'pin',
                    itemStyle: { color: '#22c55e' },
                    label: { formatter: '2022', color: '#fff', fontWeight: 'bold' }
                  },
                  {
                    name: 'Minimo',
                    value: 700,
                    xAxis: 2,
                    yAxis: 700,
                    symbol: 'pin',
                    itemStyle: { color: '#ef4444' },
                    label: { formatter: '2021', color: '#fff', fontWeight: 'bold' }
                  }
                ]
              }
            },
            {
              name: 'Neve',
              type: 'bar',
              yAxisIndex: 1,
              data: [13, 0, 8, 0, 1, 3],
              itemStyle: {
                color: '#0ea5e9',
                opacity: 0.18,
                borderColor: '#2563eb',
                borderWidth: 2
              },
              barWidth: '60%',
              emphasis: { focus: 'series' },
              markPoint: {
                symbolSize: 48,
                data: [
                  {
                    name: 'Massimo Neve',
                    value: 13,
                    xAxis: 0,
                    yAxis: 13,
                    symbol: 'pin',
                    itemStyle: {
                      color: '#fff', // Pin bianco
                      borderColor: '#2563eb',
                      borderWidth: 1.5
                    },
                    label: { formatter: '2019', color: '#2563eb', fontWeight: 'bold', fontSize: 10 }
                  }
                ]
              }
            }
          ]
        }, true);
      }
    }

    // Resize responsivo
    window.addEventListener('resize', () => {
      if (window.chart) chart.resize();
    });
    reloadBtn.addEventListener('click', () => loadData());
  </script>
</body>
</html>
